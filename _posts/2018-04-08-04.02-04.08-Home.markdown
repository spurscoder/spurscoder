---
layout: post
title: "04.02到04.08.home"
author: "Spurs"
date: 2018-04-08 12:40:00
tags:
---

> 04.02到04.08.home

<!-- more -->

## 04-02

## 04-03

### 哈工大DTP

- [对话技术平台-DTP](https://mp.weixin.qq.com/s?__biz=MzIxMjAzNDY5Mg==&mid=2650792416&idx=1&sn=a4b56d070a80dc003a80e515dc1ec610&chksm=8f47740bb830fd1d2fbd62ab595d7ebe12fac80feb9216bcac3af5f19543a77c51315ab3b4a7&scene=21#wechat_redirect)
- [dtp](http://dtp-cloud.cn/)

## 04-04

### 好的博客[我爱大泡泡](https://blog.csdn.net/woaidapaopao)

> - 面试笔试整理系列：很好很全，去年的。
> - [1](https://blog.csdn.net/woaidapaopao/article/details/77581476) ... [7](https://blog.csdn.net/woaidapaopao/article/details/78030449)
> - [常见的算法讲解很好的地址](https://blog.csdn.net/woaidapaopao/article/details/63690692)

### 数组指针和指针数组的区别

**数组指针（也称行指针）**

> 定义 int (*p)[n];
>
> ()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。

如要将二维数组赋给一指针，应这样赋值：

```c++
int a3;
int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a0
 p++;       //该语句执行过后，也就是p=p+1;p跨过行a0指向了行a1
```

所以数组指针也称指向一维数组的指针，亦称行指针。

**指针数组**

> 定义 int *p[n];
>
> []优先级高，先与p结合成为一个数组，再由int\*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1是错误的，这样赋值也是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 \*p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。

如要将二维数组赋给一指针数组:

```c++
int *p[3];
int a3;
for(i=0;i<3;i++)
p[i]=a[i];
```

这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
所以要分别赋值。

这样两者的区别就豁然开朗了，数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。
还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。
比如要表示数组中i行j列一个元素：
*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]

 

优先级：()>[]>*

### 重新认识指针

##### 对星号`*`的总结

在我们目前所学到的语法中，星号*主要有三种用途：

- 表示乘法，例如`int a = 3, b = 5, c;  c = a * b;`，这是最容易理解的。
- 表示定义一个指针变量，以和普通变量区分开，例如`int a = 100;  int *p = &a;`。
- 表示获取指针指向的数据，是一种间接操作，例如`int a, b, *p = &a;  *p = 100;  b = *p;`。

##### 我们也可以定义一个指向数组的指针，例如：

```
int arr[] = { 99, 15, 100, 888, 252 };
int *p = arr;
```

arr 本身就是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以`int *p = arr;`也可以写作`int *p = &arr[0];`。也就是说，arr、p、&arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。

##### 不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。不同的是，数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素。

##### 关于数组指针的谜题

假设 p 是指向数组 arr 中第 n 个元素的指针，那么 \*p++、\*++p、(*p)++ 分别是什么意思呢？

*p++ 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素，上面已经进行了详细讲解。

*++p 等价于 *(++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 *(p+1)，所以会获得第 n+1 个数组元素的值。

(*p)++ 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 p 指向第 0  个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0  个元素的值就会变为 100。

##### 最后我们来总结一下，C语言有两种表示字符串的方法，一种是字符数组，另一种是字符串常量，它们在内存中的存储位置不同，使得字符数组可以读取和修改，而字符串常量只能读取不能修改。

它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。

##### 对于像 int、float、char 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行内存拷贝有可能是一个漫长的过程，会严重拖慢程序的效率，为了防止技艺不佳的程序员写出低效的代码，C语言没有从语法上支持数据集合的直接赋值。

除了C语言，C++、Java、Python 等其它语言也禁止对大块内存进行拷贝，在底层都使用类似指针的方式来实现。



## 04-05

### xcode快捷键

- 局部折叠（折叠一个函数）                 ：Command+Option+Left/Right

- 全局折叠（折叠当前文件下的全部函数）：Shift+Command+Option+Left/Right

- 折叠注释块：（/* */之间的文字）       ： Ctrl+Shift+Command+Left/Right

- 当前文件的所有方法

- 折叠：

  command＋option ＋ shift ＋ 向左按键

- 展开：

  command＋option ＋ shift ＋ 向右按键

### [Google开源项目代码风格指南](http://zh-google-styleguide.readthedocs.io/en/latest/contents/)

### 重新认识指针

##### 指针数组和二维数组指针的区别

指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：

```
int *(p1[5]);  //指针数组，可以去掉括号直接写作 
int *p1[5];int (*p2)[5];  //二维数组指针，不能去掉括号
```

指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。

##### 指针（Pointer）就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。

程序在运行过程中需要的是数据和指令的地址，变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符：在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址；程序被编译和链接后，这些名字都会消失，取而代之的是它们对应的地址。

| 定  义         | 含  义                                     |
| ------------ | ---------------------------------------- |
| int *p;      | p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。 |
| int **p;     | p 为二级指针，指向 int * 类型的数据。                  |
| int *p[n];   | p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]); |
| int (*p)[n]; | p 为二维数组指针。                               |
| int *p();    | p 是一个函数，它的返回值类型为 int *。                  |
| int (*p)();  | p 是一个函数指针，指向原型为 int func() 的函数。          |

1) 指针变量可以进行加减运算，例如`p++`、`p+i`、`p-=i`。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。

2) 给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如`int *p = 1000;`是没有意义的，使用过程中一般会导致程序崩溃。

3) 使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值`NULL`。

4) 两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数。

5) 数组也是有类型的，数组名的本意是表示一组类型相同的数据。在定义数组时，或者和 sizeof、& 运算符一起使用时数组名才表示整个数组，表达式中的数组名会被转换为一个指向数组的指针。

### xcode注释函数快捷键：command + option + /

### const常量知识点

##### const type name = value; 其中const、type 可以互换位置。

##### const 和指针

const 也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。const 和指针一起使用会有几种不同的顺序，如下所示：

```
const int *p1;
int const *p2;
int * const p3;
```

在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。

当然，指针本身和它指向的数据都有可能是只读的，下面的两种写法能够做到这一点：

```
const int * const p4;
int const * const p5;
```

const 和指针结合的写法多少有点让初学者摸不着头脑，大家可以这样来记忆：const 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。

##### const和形参

在C语言中，单独定义 const 变量没有明显的优势，完全可以使用`#define`命令代替。const 通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 const 来限制。

```
size_t strlen ( const char * str );
int strcmp ( const char * str1, const char * str2 );
char * strcat ( char * destination, const char * source );
char * strcpy ( char * destination, const char * source );
int system (const char* command);
int puts ( const char * str );
int printf ( const char * format, ... );
```

### 宏定义

##### 宏定义是由源程序中的宏定义命令`#define`完成的，宏代换是由预处理程序完成的。

##### 对宏定义的几点说明

1) 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单的替换。字符串中可以含任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现。

2) 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。

3) 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用 `#undef`命令。

4) 宏名在源程序中若用引号括起来，则预处理程序不对其作宏代换

5) 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。

6) 习惯上宏名用大写字母表示，以便于与变量区别。但也允许用小写字母。

7) 可用宏定义表示数据类型，使书写方便。

```
#define UINT unsigned int
```

> 宏定义只是简单的字符串代换，是在预处理完成的，而typedef是在编译时处理的，它不是作简单的代换，而是对类型说明符重新命名。被命名的标识符具有类型定义说明的功能。
>
> ```
> #define PIN1 int *
> typedef int *PIN2;  //也可以写作typedef int (*PIN2);
> 下面用PIN1，PIN2说明变量时就可以看出它们的区别：
>     PIN1 a,b;
> 在宏代换后变成：
>     int *a,b;
> 表示a是指向整型的指针变量，而b是整型变量。然而：
>     PIN2 a,b;
> 表示a、b都是指向整型的指针变量。因为PIN2是一个类型说明符。由这个例子可见，宏定义虽然也可表示数据类型， 但毕竟是作字符代换。在使用时要分外小心，以避出错。
> ```

##### 带参数的宏和函数很相似，但有本质上的区别：宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。而函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。

### 条件编译

这种能够**根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。**条件编译是预处理程序的功能，不是编译器的功能。

条件编译形式多样，有一下几种：

- \#if命令

  ```
  #if 整型常量表达式1
      程序段1
  #elif 整型常量表达式2
      程序段2
  #elif 整型常量表达式3
      程序段3
  #else
      程序段4
  #endif
  ```

- \#ifdef 命令

  ```
  #ifdef  宏名
      程序段1
  #else
      程序段2
  #endif
  ```

- \#ifndef 命令

  ```
  #ifndef 宏名
      程序段1 
  #else 
      程序段2 
  #endif
  ```

- 最后需要注意的是，#if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的

- VS/VC有两种编译模式，一般使用的时候，是debug模式，这样便于程序的调试。另一种是release模式，这种模式会有很多优化，提高程序运行效率，产出冗余信息

  当处于debug模式时候，会有`_DEBUG`宏存在

- 另外对于windows有宏`_WIN32`，对于linux有宏`__linux__`

### C语言预处理指令总结

\#在编译器进行编译之前对源代码做某些转换

| 指令       | 说明                             |
| -------- | ------------------------------ |
| #        | 空指令，无任何效果                      |
| #include | 包含一个源代码文件                      |
| #define  | 定义宏                            |
| #undef   | 取消已定义的宏                        |
| #if      | 如果给定条件为真，则编译下面代码               |
| #ifdef   | 如果宏已经定义，则编译下面代码                |
| #ifndef  | 如果宏没有定义，则编译下面代码                |
| #elif    | 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码 |
| #endif   | 结束一个#if……#else条件编译块            |

预处理功能是C语言特有的功能，它是在对源程序正式编译前由预处理程序完成的，程序员在程序中用预处理命令来调用这些功能。

宏定义可以带有参数，宏调用时是以实参代换形参，而不是“值传送”。

为了避免宏代换时发生错误，宏定义中的字符串应加括号，字符串中出现的形式参数两边也应加括号。

文件包含是预处理的一个重要功能，它可用来把多个源文件连接成一个源文件进行编译，结果将生成一个目标文件。

条件编译允许只编译源程序中满足条件的程序段，使生成的目标程序较短，从而减少了内存的开销并提高了程序的效率。

使用预处理功能便于程序的修改、阅读、移植和调试，也便于实现模块化程序设计。

### C++中的基础问题

##### 命名空间问题

为了解决合作开发时的命名冲突问题，C++ 引入了命名空间（Namespace）的概念。

```
namespace Li{  //小李的变量定义
    FILE fp = NULL;
}
namespace Han{  //小韩的变量定义
    FILE fp = NULL
}
```

##### 我总结的 C++ 头文件的现状：

1) 旧的 C++ 头文件，如 iostream.h、fstream.h 等将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在命名空间 std 中。

2) 新的 C++ 头文件，如 iostream、fstream 等包含的基本功能和对应的旧版头文件相似，但头文件的内容在命名空间 std 中。

> 注意：在标准化的过程中，库中有些部分的细节被修改了，所以旧的头文件和新的头文件不一定完全对应。

3) 标准C头文件如 stdio.h、stdlib.h 等继续被支持。头文件的内容不在 std 中。

4) 具有C库功能的新C++头文件具有如 cstdio、cstdlib 这样的名字。它们提供的内容和相应的旧的C头文件相同，只是内容在 std 中。

**可以发现，对于不带.h的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域。这也是 C++ 标准所规定的。**

##### 使用C++的头文件

- 虽然 C++ 几乎完全兼容C语言，C语言的头文件在 C++ 中依然被支持，但 C++ 新增的库更加强大和灵活，请读者尽量使用这些 C++ 新增的头文件，例如 iostream、fstream、string 等。
- **cout 和 cin 都是 C++ 的内置对象，而不是关键字。**C++ 库定义了大量的类（Class），程序员可以使用它们来创建对象，cout 和 cin 就分别是 ostream 和 istream 类的对象，只不过它们是由标准库的开发者提前创建好的，可以直接拿来使用。**这种在 C++ 中提前创建好的对象称为内置对象。**

##### C++ 是在C语言的基础上改进的，C语言的很多语法在 C++ 中依然广泛使用，例如：

- C++ 仍然使用 char、short、int、long、float、double 等基本数据类型；
- C++ 仍然使用 if...else、while、for、switch、break 等分支或循环结构；
- C++ 仍然使用 +、-、*、/、%、++、--、<<、>> 等运算符；
- C++ 仍然使用 typedef、#define、enum、struct 等；
- C++ 仍然使用C语言中经典的指针（Pointer），并且使用范围有增无减，甚至不可或缺。

##### C++中的布尔型数据(bool)

> 注意，true 和 false 是 C++ 中的关键字。

C语言并没有彻底从语法上支持“真”和“假”，只是用 1 和 0 来代表。这点在 C++ 中得到了改善，C++ 新增了`bool`类型，它一般占用 1 个字节长度。bool 类型只有两个取值，true 和 false：true 表示“真”，false 表示“假”。

遗憾的是，在 C++ 中使用 cout 输出 bool 变量的值时还是用数字 1 和 0 表示，而不是 true 或 false。Java、PHP、JavaScript、Python等也都支持布尔类型，但输出结果为 true 或 false，我武断地认为这样更科学。

##### C++中的动态分配空间

在C语言中，动态分配内存用 malloc() 函数，释放内存用 free() 函数。

```
int *p = (int*) malloc( sizeof(int) * 10 );  //分配10个int型的内存空间
free(p);  //释放内存
```

**在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。**

用 new 和 delete 分配内存更加简单：

```
int *p = new int;  //分配1个int型的内存空间
delete p;  //释放内存

int *p = new int[10];  //分配10个int型的内存空间
delete[] p;
```

*和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现，并且不要和C语言中 malloc()、free() 一起混用。最明显的是可以自动调用构造函数和析构函数。*

##### inline函数

*函数调用是有时间和空间开销的。*程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码

```
#include <iostream>
using namespace std;
//内联函数，交换两个数的值
inline void swap(int *a, int *b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
int main(){
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap(&m, &n);
    cout<<m<<", "<<n<<endl;
    return 0;
}
```

**注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。**

*由于内联函数比较短小，我们通常的做法是省略函数原型，将整个函数定义（包括函数头和函数体）放在本应该提供函数原型的地方。*下面的例子是一个反面教材，这样的写法是不被推荐的：

```
#include <iostream>
using namespace std;
//声明内联函数
void swap1(int *a, int *b);  //也可以添加inline，但编译器会忽略
int main(){
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap1(&m, &n);
    cout<<m<<", "<<n<<endl;
    return 0;
}
//定义内联函数
inline void swap1(int *a, int *b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```

使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。

**最后需要说明的是，对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。**

##### 重载

重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。重载的结果是让一个函数名拥有了多种用途，使得命名更加方便（在中大型项目中，给变量、函数、类起名字是一件让人苦恼的问题），调用更加灵活。

在使用重载函数时，同名函数的功能应当相同或相近，不要用同一函数名去实现完全不相干的功能，虽然程序也能运行，但可读性不好，使人觉得莫名其妙。

**注意，参数列表不同包括参数的个数不同、类型不同或顺序不同，仅仅参数名称不同是不可以的。函数返回值也不能作为重载的依据。**

```
#include <iostream>
using namespace std;

//交换 int 变量的值
void Swap(int *a, int *b){
    int temp = *a;
    *a = *b;
    *b = temp;
}

//交换 float 变量的值
void Swap(float *a, float *b){
    float temp = *a;
    *a = *b;
    *b = temp;
}

//交换 char 变量的值
void Swap(char *a, char *b){
    char temp = *a;
    *a = *b;
    *b = temp;
}

//交换 bool 变量的值
void Swap(bool *a, bool *b){
    char temp = *a;
    *a = *b;
    *b = temp;
}
```

##### this 关键字

> this 是 C++ 中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。

- this 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。
- this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
- *只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用（后续会讲到 static 成员）。*

this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。

this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。

成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。

##### Static 关键字

- 静态成员变量是一种特殊的成员变量，它被关键字`static`修饰，

- 注意：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。

- 注意：static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存，

  > 使用匿名对象无法回收内存，会导致内存泄露，在中大型程序中不建议使用。


- 几点说明 

1) 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。

2) static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。

3) **静态成员变量必须初始化，而且只能在类体外进行。**例如：

int Student::m_total = 10;

**初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。**

4) 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。

##### 静态成员函数

**静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。**

和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用，上例仅仅演示了如何通过类来调用。

```c++
#include <iostream>
using namespace std;
class Student{
public:
    Student(char *name, int age, float score);
    void show();
public:  //声明静态成员函数
    static int getTotal();
    static float getPoints();
private:
    static int m_total;  //总人数
    static float m_points;  //总成绩
private:
    char *m_name;
    int m_age;
    float m_score;
};
int Student::m_total = 0;
float Student::m_points = 0.0;
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    m_total++;
    m_points += score;
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}
//定义静态成员函数
int Student::getTotal(){
    return m_total;
}
float Student::getPoints(){
    return m_points;
}
int main(){
    (new Student("小明", 15, 90.6)) -> show();
    (new Student("李磊", 16, 80.5)) -> show();
    (new Student("张华", 16, 99.0)) -> show();
    (new Student("王康", 14, 60.8)) -> show();
    int total = Student::getTotal();
    float points = Student::getPoints();
    cout<<"当前共有"<<total<<"名学生，总成绩是"<<points<<"，平均分是"<<points/total<<endl;
    return 0;
}
```

##### const关键字

在类中，如果你不希望某些数据被修改，可以使用`const`关键字加以限定。const 可以用来修饰成员变量、成员函数以及对象。
const成员变量const 成员变量的用法和普通 const 变量的用法相似，只需要在声明时加上 const 关键字。**初始化 const 成员变量只有一种方法，就是通过参数初始化表，**

const成员函数const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。

##### class和struct

C++ 中保留了C语言的 struct 关键字，并且加以扩充。在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。

C++中的 struct 和 class 基本是通用的，唯有几个细节不同：

- 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
- class 继承默认是 private 继承，而 struct 继承默认是 public 继承。
- class 可以使用模板，而 struct 不能。

### [C语言中文网](http://vip.biancheng.net/) 很好的学习C和C++的网站。

### C++中的string类详解

- 这个类大大简化了字符串的处理，[链接](http://c.biancheng.net/cpp/biancheng/view/3284.html)

### 拷贝构造函数

- 严格来说，对象的创建包括两个阶段，首先要分配内存空间，然后再进行初始化：分配内存很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。初始化就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，初始化就是调用构造函数。

- 很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存。

- ```c++
  #include <iostream>
  #include <string>
  using namespace std;
  class Student{
  public:
      Student(string name = "", int age = 0, float score = 0.0f);  //普通构造函数
      Student(const Student &stu);  //拷贝构造函数（声明）
  public:
      void display();
  private:
      string m_name;
      int m_age;
      float m_score;
  };
  Student::Student(string name, int age, float score): m_name(name), m_age(age), m_score(score){ }
  //拷贝构造函数（定义）
  Student::Student(const Student &stu){
      this->m_name = stu.m_name;
      this->m_age = stu.m_age;
      this->m_score = stu.m_score;
     
      cout<<"Copy constructor was called."<<endl;
  }
  void Student::display(){
      cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
  }
  int main(){
      Student stu1("小明", 16, 90.5);
      Student stu2 = stu1;  //调用拷贝构造函数
      Student stu3(stu1);  //调用拷贝构造函数
      stu1.display();
      stu2.display();
      stu3.display();
     
      return 0;
  }
  ```

  - 1) 为什么必须是当前类的引用呢？

  如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。

  只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。

  - 2) 为什么是 const 引用呢？

  拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。

  另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。

  - 默认拷贝构造函数

- 深拷贝还是浅拷贝

  > 默认的拷贝行为就是浅拷贝，这和调用 memcpy() 函数的效果非常类似。

  >  这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。

##04-06

###最小生成树算法：普里姆算法、克鲁斯卡尔算法

###求最短路径：迪杰斯特拉算法、弗洛伊德算法
### 方差(bias)偏差(variance)权衡

- Bias和Variance分别从两个不同的方面描述了我们学习到的模型与真实模型之间的差距
- **Bias**描述的是对于测试数据集，“用所有可能的训练数据集训练出来的所有模型的输出预测结果的期望”与“真实模型”的输出值(样本真实结果)之间的差异。*简单来说，就是再训练集上拟合的好不好？。要想在bias上表现好，low bias，就是复杂化模型，增加模型的参数，但是这样容易导致过拟合。
- **Variance**则是“不同训练数据集合训练出的模型”的输出值之间的差异
- 在一个实际系统中，Bias与Variance往往是不可兼得的。


## 04-07

## 04-08

## END

